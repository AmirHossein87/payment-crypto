//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase, HttpContext } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AppsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    update(appId: number, request: UpdateAppRequest, httpContext?: HttpContext): Observable<App> {
        let url_ = this.baseUrl + "/api/apps/{appId}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<App>;
                }
            } else
                return _observableThrow(response_) as any as Observable<App>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<App> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = App.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(appId: number, httpContext?: HttpContext): Observable<App> {
        let url_ = this.baseUrl + "/api/apps/{appId}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<App>;
                }
            } else
                return _observableThrow(response_) as any as Observable<App>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<App> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = App.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class HostedPageClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getPaymentSession(appId: number, paymentKey: string, httpContext?: HttpContext): Observable<PaymentSession> {
        let url_ = this.baseUrl + "/api/apps/{appId}/hosted-page/{paymentKey}/payment-session";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (paymentKey === undefined || paymentKey === null)
            throw new Error("The parameter 'paymentKey' must be defined.");
        url_ = url_.replace("{paymentKey}", encodeURIComponent("" + paymentKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentSession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentSession(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentSession>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentSession>;
        }));
    }

    protected processGetPaymentSession(response: HttpResponseBase): Observable<PaymentSession> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentSession.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    refreshStatus(appId: number, paymentKey: string, httpContext?: HttpContext): Observable<Payment> {
        let url_ = this.baseUrl + "/api/apps/{appId}/hosted-page/{paymentKey}/refresh-status";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (paymentKey === undefined || paymentKey === null)
            throw new Error("The parameter 'paymentKey' must be defined.");
        url_ = url_.replace("{paymentKey}", encodeURIComponent("" + paymentKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Payment>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Payment>;
        }));
    }

    protected processRefreshStatus(response: HttpResponseBase): Observable<Payment> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Payment.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PaymentsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    create(appId: number, request: CreatePaymentRequest, httpContext?: HttpContext): Observable<Payment> {
        let url_ = this.baseUrl + "/api/apps/{appId}/payments";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Payment>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Payment>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Payment> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Payment.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(appId: number, paymentId: number, httpContext?: HttpContext): Observable<Payment> {
        let url_ = this.baseUrl + "/api/apps/{appId}/payments/{paymentId}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (paymentId === undefined || paymentId === null)
            throw new Error("The parameter 'paymentId' must be defined.");
        url_ = url_.replace("{paymentId}", encodeURIComponent("" + paymentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Payment>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Payment>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Payment> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Payment.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    markAsPaid(appId: number, paymentId: number, httpContext?: HttpContext): Observable<Payment> {
        let url_ = this.baseUrl + "/api/apps/{appId}/payments/{paymentId}/mark-as-paid";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (paymentId === undefined || paymentId === null)
            throw new Error("The parameter 'paymentId' must be defined.");
        url_ = url_.replace("{paymentId}", encodeURIComponent("" + paymentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAsPaid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAsPaid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Payment>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Payment>;
        }));
    }

    protected processMarkAsPaid(response: HttpResponseBase): Observable<Payment> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Payment.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    markAsFailed(appId: number, paymentId: number, httpContext?: HttpContext): Observable<Payment> {
        let url_ = this.baseUrl + "/api/apps/{appId}/payments/{paymentId}/mark-as-failed";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (paymentId === undefined || paymentId === null)
            throw new Error("The parameter 'paymentId' must be defined.");
        url_ = url_.replace("{paymentId}", encodeURIComponent("" + paymentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAsFailed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAsFailed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Payment>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Payment>;
        }));
    }

    protected processMarkAsFailed(response: HttpResponseBase): Observable<Payment> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Payment.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SystemClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    createApp(httpContext?: HttpContext): Observable<App> {
        let url_ = this.baseUrl + "/api/apps";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateApp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateApp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<App>;
                }
            } else
                return _observableThrow(response_) as any as Observable<App>;
        }));
    }

    protected processCreateApp(response: HttpResponseBase): Observable<App> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = App.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TeamClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    listCurrentUserResources(httpContext?: HttpContext): Observable<string[]> {
        let url_ = this.baseUrl + "/api/team/users/current/resources";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListCurrentUserResources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListCurrentUserResources(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processListCurrentUserResources(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    listCurrentUserPermissions(resourceId: string, httpContext?: HttpContext): Observable<string[]> {
        let url_ = this.baseUrl + "/api/team/users/current/resources/{resourceId}/permissions";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListCurrentUserPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListCurrentUserPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processListCurrentUserPermissions(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    resetBotApiKey(userId: string, httpContext?: HttpContext): Observable<ApiKey> {
        let url_ = this.baseUrl + "/api/team/users/{userId}/bot/reset-api-key";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetBotApiKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetBotApiKey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiKey>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiKey>;
        }));
    }

    protected processResetBotApiKey(response: HttpResponseBase): Observable<ApiKey> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiKey.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateBot(userId: string, updateParam: TeamUpdateBotParam, httpContext?: HttpContext): Observable<User> {
        let url_ = this.baseUrl + "/api/team/users/{userId}/bot";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateParam);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBot(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBot(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User>;
        }));
    }

    protected processUpdateBot(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    listRoles(resourceId: string, httpContext?: HttpContext): Observable<Role[]> {
        let url_ = this.baseUrl + "/api/team/resources/{resourceId}/roles";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Role[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Role[]>;
        }));
    }

    protected processListRoles(response: HttpResponseBase): Observable<Role[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Role.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    listUserRoles(resourceId: string, roleId?: string | null | undefined, userId?: string | null | undefined, search?: string | null | undefined, isBot?: boolean | null | undefined, recordIndex?: number | undefined, recordCount?: number | null | undefined, httpContext?: HttpContext): Observable<ListResultOfTeamUserRole> {
        let url_ = this.baseUrl + "/api/team/resources/{resourceId}/user-roles?";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (roleId !== undefined && roleId !== null)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (isBot !== undefined && isBot !== null)
            url_ += "isBot=" + encodeURIComponent("" + isBot) + "&";
        if (recordIndex === null)
            throw new Error("The parameter 'recordIndex' cannot be null.");
        else if (recordIndex !== undefined)
            url_ += "recordIndex=" + encodeURIComponent("" + recordIndex) + "&";
        if (recordCount !== undefined && recordCount !== null)
            url_ += "recordCount=" + encodeURIComponent("" + recordCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListUserRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListUserRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultOfTeamUserRole>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultOfTeamUserRole>;
        }));
    }

    protected processListUserRoles(response: HttpResponseBase): Observable<ListResultOfTeamUserRole> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultOfTeamUserRole.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUser(resourceId: string, userId: string, httpContext?: HttpContext): Observable<TeamUserOfUserAndRole> {
        let url_ = this.baseUrl + "/api/team/resources/{resourceId}/users/{userId}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeamUserOfUserAndRole>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeamUserOfUserAndRole>;
        }));
    }

    protected processGetUser(response: HttpResponseBase): Observable<TeamUserOfUserAndRole> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeamUserOfUserAndRole.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserByEmail(resourceId: string, email: string, httpContext?: HttpContext): Observable<TeamUserOfUserAndRole> {
        let url_ = this.baseUrl + "/api/team/resources/{resourceId}/users/email:{email}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserByEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserByEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeamUserOfUserAndRole>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeamUserOfUserAndRole>;
        }));
    }

    protected processGetUserByEmail(response: HttpResponseBase): Observable<TeamUserOfUserAndRole> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeamUserOfUserAndRole.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addNewBot(resourceId: string, roleId: string, addParam: TeamAddBotParam, httpContext?: HttpContext): Observable<ApiKey> {
        let url_ = this.baseUrl + "/api/team/resources/{resourceId}/roles/{roleId}/bots";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addParam);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNewBot(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNewBot(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiKey>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiKey>;
        }));
    }

    protected processAddNewBot(response: HttpResponseBase): Observable<ApiKey> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiKey.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addUserByEmail(resourceId: string, roleId: string, email: string, addParam?: TeamAddEmailParam | undefined, httpContext?: HttpContext): Observable<TeamUserRole> {
        let url_ = this.baseUrl + "/api/team/resources/{resourceId}/roles/{roleId}/users/email:{email}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addParam);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUserByEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUserByEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeamUserRole>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeamUserRole>;
        }));
    }

    protected processAddUserByEmail(response: HttpResponseBase): Observable<TeamUserRole> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeamUserRole.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addUser(resourceId: string, roleId: string, userId: string, httpContext?: HttpContext): Observable<TeamUserRole> {
        let url_ = this.baseUrl + "/api/team/resources/{resourceId}/roles/{roleId}/users/{userId}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeamUserRole>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeamUserRole>;
        }));
    }

    protected processAddUser(response: HttpResponseBase): Observable<TeamUserRole> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeamUserRole.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeUser(resourceId: string, roleId: string, userId: string, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/team/resources/{resourceId}/roles/{roleId}/users/{userId}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createSystemApiKey(secret: string, httpContext?: HttpContext): Observable<ApiKey> {
        let url_ = this.baseUrl + "/api/team/system/api-key";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (secret === null || secret === undefined)
            throw new Error("The parameter 'secret' cannot be null.");
        else
            content_.append("secret", secret.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSystemApiKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSystemApiKey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiKey>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiKey>;
        }));
    }

    protected processCreateSystemApiKey(response: HttpResponseBase): Observable<ApiKey> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiKey.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AuthenticationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getCurrentUser(httpContext?: HttpContext): Observable<User> {
        let url_ = this.baseUrl + "/api/authentication/current";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User>;
        }));
    }

    protected processGetCurrentUser(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    signOutAll(httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/authentication/current/signout-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignOutAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignOutAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSignOutAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    resetCurrentUserApiKey(httpContext?: HttpContext): Observable<ApiKey> {
        let url_ = this.baseUrl + "/api/authentication/current/reset-api-key";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetCurrentUserApiKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetCurrentUserApiKey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiKey>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiKey>;
        }));
    }

    protected processResetCurrentUserApiKey(response: HttpResponseBase): Observable<ApiKey> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiKey.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    signIn(request: SignInRequest, httpContext?: HttpContext): Observable<ApiKey> {
        let url_ = this.baseUrl + "/api/authentication/signin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignIn(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiKey>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiKey>;
        }));
    }

    protected processSignIn(response: HttpResponseBase): Observable<ApiKey> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiKey.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    signUp(request: SignUpRequest, httpContext?: HttpContext): Observable<ApiKey> {
        let url_ = this.baseUrl + "/api/authentication/signup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignUp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiKey>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiKey>;
        }));
    }

    protected processSignUp(response: HttpResponseBase): Observable<ApiKey> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiKey.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    refreshToken(request: RefreshTokenRequest, httpContext?: HttpContext): Observable<ApiKey> {
        let url_ = this.baseUrl + "/api/authentication/refresh-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiKey>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiKey>;
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<ApiKey> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiKey.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    googleSignInHandler(httpContext?: HttpContext): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/authentication/external/google/signin-handler";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGoogleSignInHandler(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGoogleSignInHandler(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGoogleSignInHandler(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getGoogleSignInUrl(csrfToken: string, nonce?: string | null | undefined, httpContext?: HttpContext): Observable<string> {
        let url_ = this.baseUrl + "/api/authentication/external/google/signin-url?";
        if (csrfToken === undefined || csrfToken === null)
            throw new Error("The parameter 'csrfToken' must be defined and cannot be null.");
        else
            url_ += "csrfToken=" + encodeURIComponent("" + csrfToken) + "&";
        if (nonce !== undefined && nonce !== null)
            url_ += "nonce=" + encodeURIComponent("" + nonce) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGoogleSignInUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGoogleSignInUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetGoogleSignInUrl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class App implements IApp {
    appId!: number;
    paymentWebhookUrl?: string | null;
    checkoutBaseUrl?: string | null;
    webhookAuthorizationHeaderScheme?: string | null;
    webhookAuthorizationHeaderParameter?: string | null;
    isSandbox!: boolean;
    paymentTolerancePercentage!: number;

    constructor(data?: IApp) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appId = _data["appId"] !== undefined ? _data["appId"] : <any>null;
            this.paymentWebhookUrl = _data["paymentWebhookUrl"] !== undefined ? _data["paymentWebhookUrl"] : <any>null;
            this.checkoutBaseUrl = _data["checkoutBaseUrl"] !== undefined ? _data["checkoutBaseUrl"] : <any>null;
            this.webhookAuthorizationHeaderScheme = _data["webhookAuthorizationHeaderScheme"] !== undefined ? _data["webhookAuthorizationHeaderScheme"] : <any>null;
            this.webhookAuthorizationHeaderParameter = _data["webhookAuthorizationHeaderParameter"] !== undefined ? _data["webhookAuthorizationHeaderParameter"] : <any>null;
            this.isSandbox = _data["isSandbox"] !== undefined ? _data["isSandbox"] : <any>null;
            this.paymentTolerancePercentage = _data["paymentTolerancePercentage"] !== undefined ? _data["paymentTolerancePercentage"] : <any>null;
        }
    }

    static fromJS(data: any): App {
        data = typeof data === 'object' ? data : {};
        let result = new App();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appId"] = this.appId !== undefined ? this.appId : <any>null;
        data["paymentWebhookUrl"] = this.paymentWebhookUrl !== undefined ? this.paymentWebhookUrl : <any>null;
        data["checkoutBaseUrl"] = this.checkoutBaseUrl !== undefined ? this.checkoutBaseUrl : <any>null;
        data["webhookAuthorizationHeaderScheme"] = this.webhookAuthorizationHeaderScheme !== undefined ? this.webhookAuthorizationHeaderScheme : <any>null;
        data["webhookAuthorizationHeaderParameter"] = this.webhookAuthorizationHeaderParameter !== undefined ? this.webhookAuthorizationHeaderParameter : <any>null;
        data["isSandbox"] = this.isSandbox !== undefined ? this.isSandbox : <any>null;
        data["paymentTolerancePercentage"] = this.paymentTolerancePercentage !== undefined ? this.paymentTolerancePercentage : <any>null;
        return data;
    }
}

export interface IApp {
    appId: number;
    paymentWebhookUrl?: string | null;
    checkoutBaseUrl?: string | null;
    webhookAuthorizationHeaderScheme?: string | null;
    webhookAuthorizationHeaderParameter?: string | null;
    isSandbox: boolean;
    paymentTolerancePercentage: number;
}

export class UpdateAppRequest implements IUpdateAppRequest {
    invoiceWebhookUrl?: PatchOfUri | null;
    checkoutBaseUrl?: PatchOfUri | null;
    webhookAuthorizationHeaderScheme?: PatchOfString | null;
    webhookAuthorizationHeaderParameter?: PatchOfString | null;
    paymentTolerancePercentage?: PatchOfDecimal | null;

    constructor(data?: IUpdateAppRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invoiceWebhookUrl = _data["invoiceWebhookUrl"] ? PatchOfUri.fromJS(_data["invoiceWebhookUrl"]) : <any>null;
            this.checkoutBaseUrl = _data["checkoutBaseUrl"] ? PatchOfUri.fromJS(_data["checkoutBaseUrl"]) : <any>null;
            this.webhookAuthorizationHeaderScheme = _data["webhookAuthorizationHeaderScheme"] ? PatchOfString.fromJS(_data["webhookAuthorizationHeaderScheme"]) : <any>null;
            this.webhookAuthorizationHeaderParameter = _data["webhookAuthorizationHeaderParameter"] ? PatchOfString.fromJS(_data["webhookAuthorizationHeaderParameter"]) : <any>null;
            this.paymentTolerancePercentage = _data["paymentTolerancePercentage"] ? PatchOfDecimal.fromJS(_data["paymentTolerancePercentage"]) : <any>null;
        }
    }

    static fromJS(data: any): UpdateAppRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAppRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceWebhookUrl"] = this.invoiceWebhookUrl ? this.invoiceWebhookUrl.toJSON() : <any>null;
        data["checkoutBaseUrl"] = this.checkoutBaseUrl ? this.checkoutBaseUrl.toJSON() : <any>null;
        data["webhookAuthorizationHeaderScheme"] = this.webhookAuthorizationHeaderScheme ? this.webhookAuthorizationHeaderScheme.toJSON() : <any>null;
        data["webhookAuthorizationHeaderParameter"] = this.webhookAuthorizationHeaderParameter ? this.webhookAuthorizationHeaderParameter.toJSON() : <any>null;
        data["paymentTolerancePercentage"] = this.paymentTolerancePercentage ? this.paymentTolerancePercentage.toJSON() : <any>null;
        return data;
    }
}

export interface IUpdateAppRequest {
    invoiceWebhookUrl?: PatchOfUri | null;
    checkoutBaseUrl?: PatchOfUri | null;
    webhookAuthorizationHeaderScheme?: PatchOfString | null;
    webhookAuthorizationHeaderParameter?: PatchOfString | null;
    paymentTolerancePercentage?: PatchOfDecimal | null;
}

export class PatchOfUri implements IPatchOfUri {
    value?: string | null;

    constructor(data?: IPatchOfUri) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): PatchOfUri {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfUri();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IPatchOfUri {
    value?: string | null;
}

export class PatchOfString implements IPatchOfString {
    value?: string | null;

    constructor(data?: IPatchOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): PatchOfString {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IPatchOfString {
    value?: string | null;
}

export class PatchOfDecimal implements IPatchOfDecimal {
    value!: number;

    constructor(data?: IPatchOfDecimal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): PatchOfDecimal {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfDecimal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IPatchOfDecimal {
    value: number;
}

export class PaymentSession implements IPaymentSession {
    paymentId!: number;
    amount!: PaymentAmount;
    capturedAmount?: number | null;
    cryptoAmount!: CryptoAmount;
    returnUrl?: string | null;
    receiverWalletAddress!: string;
    referenceNumber!: string;
    paymentState!: PaymentState;
    lastError?: string | null;
    createdTime!: Date;
    expireAt!: Date;

    constructor(data?: IPaymentSession) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.amount = new PaymentAmount();
            this.cryptoAmount = new CryptoAmount();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentId = _data["paymentId"] !== undefined ? _data["paymentId"] : <any>null;
            this.amount = _data["amount"] ? PaymentAmount.fromJS(_data["amount"]) : new PaymentAmount();
            this.capturedAmount = _data["capturedAmount"] !== undefined ? _data["capturedAmount"] : <any>null;
            this.cryptoAmount = _data["cryptoAmount"] ? CryptoAmount.fromJS(_data["cryptoAmount"]) : new CryptoAmount();
            this.returnUrl = _data["returnUrl"] !== undefined ? _data["returnUrl"] : <any>null;
            this.receiverWalletAddress = _data["receiverWalletAddress"] !== undefined ? _data["receiverWalletAddress"] : <any>null;
            this.referenceNumber = _data["referenceNumber"] !== undefined ? _data["referenceNumber"] : <any>null;
            this.paymentState = _data["paymentState"] !== undefined ? _data["paymentState"] : <any>null;
            this.lastError = _data["lastError"] !== undefined ? _data["lastError"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.expireAt = _data["expireAt"] ? new Date(_data["expireAt"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): PaymentSession {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentSession();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId !== undefined ? this.paymentId : <any>null;
        data["amount"] = this.amount ? this.amount.toJSON() : <any>null;
        data["capturedAmount"] = this.capturedAmount !== undefined ? this.capturedAmount : <any>null;
        data["cryptoAmount"] = this.cryptoAmount ? this.cryptoAmount.toJSON() : <any>null;
        data["returnUrl"] = this.returnUrl !== undefined ? this.returnUrl : <any>null;
        data["receiverWalletAddress"] = this.receiverWalletAddress !== undefined ? this.receiverWalletAddress : <any>null;
        data["referenceNumber"] = this.referenceNumber !== undefined ? this.referenceNumber : <any>null;
        data["paymentState"] = this.paymentState !== undefined ? this.paymentState : <any>null;
        data["lastError"] = this.lastError !== undefined ? this.lastError : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["expireAt"] = this.expireAt ? this.expireAt.toISOString() : <any>null;
        return data;
    }
}

export interface IPaymentSession {
    paymentId: number;
    amount: PaymentAmount;
    capturedAmount?: number | null;
    cryptoAmount: CryptoAmount;
    returnUrl?: string | null;
    receiverWalletAddress: string;
    referenceNumber: string;
    paymentState: PaymentState;
    lastError?: string | null;
    createdTime: Date;
    expireAt: Date;
}

export class PaymentAmount implements IPaymentAmount {
    amount!: number;
    currency!: Currency;

    constructor(data?: IPaymentAmount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
            this.currency = _data["currency"] !== undefined ? _data["currency"] : <any>null;
        }
    }

    static fromJS(data: any): PaymentAmount {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentAmount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["currency"] = this.currency !== undefined ? this.currency : <any>null;
        return data;
    }
}

export interface IPaymentAmount {
    amount: number;
    currency: Currency;
}

export enum Currency {
    USD = "USD",
}

export class CryptoAmount implements ICryptoAmount {
    amount!: number;
    cryptoNetwork!: CryptoNetwork;

    constructor(data?: ICryptoAmount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.cryptoNetwork = new CryptoNetwork();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
            this.cryptoNetwork = _data["cryptoNetwork"] ? CryptoNetwork.fromJS(_data["cryptoNetwork"]) : new CryptoNetwork();
        }
    }

    static fromJS(data: any): CryptoAmount {
        data = typeof data === 'object' ? data : {};
        let result = new CryptoAmount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["cryptoNetwork"] = this.cryptoNetwork ? this.cryptoNetwork.toJSON() : <any>null;
        return data;
    }
}

export interface ICryptoAmount {
    amount: number;
    cryptoNetwork: CryptoNetwork;
}

export class CryptoNetwork implements ICryptoNetwork {
    cryptoNetworkId!: number;
    blockchain!: Blockchain;
    tokenStandard!: TokenStandard;
    nativeToken!: NativeToken;
    symbol!: string;

    constructor(data?: ICryptoNetwork) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cryptoNetworkId = _data["cryptoNetworkId"] !== undefined ? _data["cryptoNetworkId"] : <any>null;
            this.blockchain = _data["blockchain"] !== undefined ? _data["blockchain"] : <any>null;
            this.tokenStandard = _data["tokenStandard"] !== undefined ? _data["tokenStandard"] : <any>null;
            this.nativeToken = _data["nativeToken"] !== undefined ? _data["nativeToken"] : <any>null;
            this.symbol = _data["symbol"] !== undefined ? _data["symbol"] : <any>null;
        }
    }

    static fromJS(data: any): CryptoNetwork {
        data = typeof data === 'object' ? data : {};
        let result = new CryptoNetwork();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cryptoNetworkId"] = this.cryptoNetworkId !== undefined ? this.cryptoNetworkId : <any>null;
        data["blockchain"] = this.blockchain !== undefined ? this.blockchain : <any>null;
        data["tokenStandard"] = this.tokenStandard !== undefined ? this.tokenStandard : <any>null;
        data["nativeToken"] = this.nativeToken !== undefined ? this.nativeToken : <any>null;
        data["symbol"] = this.symbol !== undefined ? this.symbol : <any>null;
        return data;
    }
}

export interface ICryptoNetwork {
    cryptoNetworkId: number;
    blockchain: Blockchain;
    tokenStandard: TokenStandard;
    nativeToken: NativeToken;
    symbol: string;
}

export enum Blockchain {
    Tron = "Tron",
}

export enum TokenStandard {
    TRC20 = "TRC20",
}

export enum NativeToken {
    TRX = "TRX",
}

export enum PaymentState {
    Reserved = "Reserved",
    Created = "Created",
    UnderPaid = "UnderPaid",
    OverPaid = "OverPaid",
    Paid = "Paid",
    Failed = "Failed",
    Processing = "Processing",
    Hold = "Hold",
}

export class Payment implements IPayment {
    paymentId!: number;
    appId!: number;
    amount!: PaymentAmount;
    cryptoAmount!: CryptoAmount;
    capturedAmount?: number | null;
    referenceNumber!: string;
    paymentState!: PaymentState;
    lastError?: string | null;
    receiverWalletAddress!: string;
    senderWalletAddress?: string | null;
    checkoutUrl!: string;
    returnUrl?: string | null;
    webhookUrl?: string | null;
    createdTime!: Date;
    createdByUserId?: string | null;
    modifiedTime!: Date;

    constructor(data?: IPayment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.amount = new PaymentAmount();
            this.cryptoAmount = new CryptoAmount();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentId = _data["paymentId"] !== undefined ? _data["paymentId"] : <any>null;
            this.appId = _data["appId"] !== undefined ? _data["appId"] : <any>null;
            this.amount = _data["amount"] ? PaymentAmount.fromJS(_data["amount"]) : new PaymentAmount();
            this.cryptoAmount = _data["cryptoAmount"] ? CryptoAmount.fromJS(_data["cryptoAmount"]) : new CryptoAmount();
            this.capturedAmount = _data["capturedAmount"] !== undefined ? _data["capturedAmount"] : <any>null;
            this.referenceNumber = _data["referenceNumber"] !== undefined ? _data["referenceNumber"] : <any>null;
            this.paymentState = _data["paymentState"] !== undefined ? _data["paymentState"] : <any>null;
            this.lastError = _data["lastError"] !== undefined ? _data["lastError"] : <any>null;
            this.receiverWalletAddress = _data["receiverWalletAddress"] !== undefined ? _data["receiverWalletAddress"] : <any>null;
            this.senderWalletAddress = _data["senderWalletAddress"] !== undefined ? _data["senderWalletAddress"] : <any>null;
            this.checkoutUrl = _data["checkoutUrl"] !== undefined ? _data["checkoutUrl"] : <any>null;
            this.returnUrl = _data["returnUrl"] !== undefined ? _data["returnUrl"] : <any>null;
            this.webhookUrl = _data["webhookUrl"] !== undefined ? _data["webhookUrl"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.createdByUserId = _data["createdByUserId"] !== undefined ? _data["createdByUserId"] : <any>null;
            this.modifiedTime = _data["modifiedTime"] ? new Date(_data["modifiedTime"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): Payment {
        data = typeof data === 'object' ? data : {};
        let result = new Payment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId !== undefined ? this.paymentId : <any>null;
        data["appId"] = this.appId !== undefined ? this.appId : <any>null;
        data["amount"] = this.amount ? this.amount.toJSON() : <any>null;
        data["cryptoAmount"] = this.cryptoAmount ? this.cryptoAmount.toJSON() : <any>null;
        data["capturedAmount"] = this.capturedAmount !== undefined ? this.capturedAmount : <any>null;
        data["referenceNumber"] = this.referenceNumber !== undefined ? this.referenceNumber : <any>null;
        data["paymentState"] = this.paymentState !== undefined ? this.paymentState : <any>null;
        data["lastError"] = this.lastError !== undefined ? this.lastError : <any>null;
        data["receiverWalletAddress"] = this.receiverWalletAddress !== undefined ? this.receiverWalletAddress : <any>null;
        data["senderWalletAddress"] = this.senderWalletAddress !== undefined ? this.senderWalletAddress : <any>null;
        data["checkoutUrl"] = this.checkoutUrl !== undefined ? this.checkoutUrl : <any>null;
        data["returnUrl"] = this.returnUrl !== undefined ? this.returnUrl : <any>null;
        data["webhookUrl"] = this.webhookUrl !== undefined ? this.webhookUrl : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["createdByUserId"] = this.createdByUserId !== undefined ? this.createdByUserId : <any>null;
        data["modifiedTime"] = this.modifiedTime ? this.modifiedTime.toISOString() : <any>null;
        return data;
    }
}

export interface IPayment {
    paymentId: number;
    appId: number;
    amount: PaymentAmount;
    cryptoAmount: CryptoAmount;
    capturedAmount?: number | null;
    referenceNumber: string;
    paymentState: PaymentState;
    lastError?: string | null;
    receiverWalletAddress: string;
    senderWalletAddress?: string | null;
    checkoutUrl: string;
    returnUrl?: string | null;
    webhookUrl?: string | null;
    createdTime: Date;
    createdByUserId?: string | null;
    modifiedTime: Date;
}

export class CreatePaymentRequest implements ICreatePaymentRequest {
    amount!: number;
    currency!: Currency;
    returnUrl?: string | null;
    webhookUrl?: string | null;
    referenceNumber!: string;

    constructor(data?: ICreatePaymentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
            this.currency = _data["currency"] !== undefined ? _data["currency"] : <any>null;
            this.returnUrl = _data["returnUrl"] !== undefined ? _data["returnUrl"] : <any>null;
            this.webhookUrl = _data["webhookUrl"] !== undefined ? _data["webhookUrl"] : <any>null;
            this.referenceNumber = _data["referenceNumber"] !== undefined ? _data["referenceNumber"] : <any>null;
        }
    }

    static fromJS(data: any): CreatePaymentRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["currency"] = this.currency !== undefined ? this.currency : <any>null;
        data["returnUrl"] = this.returnUrl !== undefined ? this.returnUrl : <any>null;
        data["webhookUrl"] = this.webhookUrl !== undefined ? this.webhookUrl : <any>null;
        data["referenceNumber"] = this.referenceNumber !== undefined ? this.referenceNumber : <any>null;
        return data;
    }
}

export interface ICreatePaymentRequest {
    amount: number;
    currency: Currency;
    returnUrl?: string | null;
    webhookUrl?: string | null;
    referenceNumber: string;
}

export class ApiKey implements IApiKey {
    accessToken!: Token;
    refreshToken?: Token | null;
    userId!: string;

    constructor(data?: IApiKey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.accessToken = new Token();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"] ? Token.fromJS(_data["accessToken"]) : new Token();
            this.refreshToken = _data["refreshToken"] ? Token.fromJS(_data["refreshToken"]) : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
        }
    }

    static fromJS(data: any): ApiKey {
        data = typeof data === 'object' ? data : {};
        let result = new ApiKey();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken ? this.accessToken.toJSON() : <any>null;
        data["refreshToken"] = this.refreshToken ? this.refreshToken.toJSON() : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        return data;
    }
}

export interface IApiKey {
    accessToken: Token;
    refreshToken?: Token | null;
    userId: string;
}

export class Token implements IToken {
    value!: string;
    expirationTime!: Date;
    scheme!: string;
    issuedTime!: Date;

    constructor(data?: IToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
            this.expirationTime = _data["expirationTime"] ? new Date(_data["expirationTime"].toString()) : <any>null;
            this.scheme = _data["scheme"] !== undefined ? _data["scheme"] : <any>null;
            this.issuedTime = _data["issuedTime"] ? new Date(_data["issuedTime"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): Token {
        data = typeof data === 'object' ? data : {};
        let result = new Token();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        data["expirationTime"] = this.expirationTime ? this.expirationTime.toISOString() : <any>null;
        data["scheme"] = this.scheme !== undefined ? this.scheme : <any>null;
        data["issuedTime"] = this.issuedTime ? this.issuedTime.toISOString() : <any>null;
        return data;
    }
}

export interface IToken {
    value: string;
    expirationTime: Date;
    scheme: string;
    issuedTime: Date;
}

export class User implements IUser {
    userId!: string;
    email?: string | null;
    name?: string | null;
    firstName?: string | null;
    lastName?: string | null;
    pictureUrl?: string | null;
    phone?: string | null;
    createdTime!: Date;
    accessedTime?: Date | null;
    authorizationCode?: string | null;
    isDisabled!: boolean;
    isEmailVerified!: boolean;
    isPhoneVerified!: boolean;
    isBot!: boolean;
    description?: string | null;
    exData?: string | null;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.pictureUrl = _data["pictureUrl"] !== undefined ? _data["pictureUrl"] : <any>null;
            this.phone = _data["phone"] !== undefined ? _data["phone"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.accessedTime = _data["accessedTime"] ? new Date(_data["accessedTime"].toString()) : <any>null;
            this.authorizationCode = _data["authorizationCode"] !== undefined ? _data["authorizationCode"] : <any>null;
            this.isDisabled = _data["isDisabled"] !== undefined ? _data["isDisabled"] : <any>null;
            this.isEmailVerified = _data["isEmailVerified"] !== undefined ? _data["isEmailVerified"] : <any>null;
            this.isPhoneVerified = _data["isPhoneVerified"] !== undefined ? _data["isPhoneVerified"] : <any>null;
            this.isBot = _data["isBot"] !== undefined ? _data["isBot"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.exData = _data["exData"] !== undefined ? _data["exData"] : <any>null;
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["pictureUrl"] = this.pictureUrl !== undefined ? this.pictureUrl : <any>null;
        data["phone"] = this.phone !== undefined ? this.phone : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["accessedTime"] = this.accessedTime ? this.accessedTime.toISOString() : <any>null;
        data["authorizationCode"] = this.authorizationCode !== undefined ? this.authorizationCode : <any>null;
        data["isDisabled"] = this.isDisabled !== undefined ? this.isDisabled : <any>null;
        data["isEmailVerified"] = this.isEmailVerified !== undefined ? this.isEmailVerified : <any>null;
        data["isPhoneVerified"] = this.isPhoneVerified !== undefined ? this.isPhoneVerified : <any>null;
        data["isBot"] = this.isBot !== undefined ? this.isBot : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["exData"] = this.exData !== undefined ? this.exData : <any>null;
        return data;
    }
}

export interface IUser {
    userId: string;
    email?: string | null;
    name?: string | null;
    firstName?: string | null;
    lastName?: string | null;
    pictureUrl?: string | null;
    phone?: string | null;
    createdTime: Date;
    accessedTime?: Date | null;
    authorizationCode?: string | null;
    isDisabled: boolean;
    isEmailVerified: boolean;
    isPhoneVerified: boolean;
    isBot: boolean;
    description?: string | null;
    exData?: string | null;
}

export class TeamUpdateBotParam implements ITeamUpdateBotParam {
    name?: PatchOfString | null;

    constructor(data?: ITeamUpdateBotParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] ? PatchOfString.fromJS(_data["name"]) : <any>null;
        }
    }

    static fromJS(data: any): TeamUpdateBotParam {
        data = typeof data === 'object' ? data : {};
        let result = new TeamUpdateBotParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name ? this.name.toJSON() : <any>null;
        return data;
    }
}

export interface ITeamUpdateBotParam {
    name?: PatchOfString | null;
}

export class Role implements IRole {
    roleId!: string;
    roleName!: string;
    description?: string | null;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"] !== undefined ? _data["roleId"] : <any>null;
            this.roleName = _data["roleName"] !== undefined ? _data["roleName"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId !== undefined ? this.roleId : <any>null;
        data["roleName"] = this.roleName !== undefined ? this.roleName : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

export interface IRole {
    roleId: string;
    roleName: string;
    description?: string | null;
}

export class ListResultOfTeamUserRole implements IListResultOfTeamUserRole {
    totalCount?: number | null;
    items!: TeamUserRole[];

    constructor(data?: IListResultOfTeamUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TeamUserRole.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
        }
    }

    static fromJS(data: any): ListResultOfTeamUserRole {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultOfTeamUserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultOfTeamUserRole {
    totalCount?: number | null;
    items: TeamUserRole[];
}

export class UserRole implements IUserRole {
    resourceId!: string;
    userId!: string;
    role!: Role;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new Role();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resourceId = _data["resourceId"] !== undefined ? _data["resourceId"] : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.role = _data["role"] ? Role.fromJS(_data["role"]) : new Role();
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceId"] = this.resourceId !== undefined ? this.resourceId : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["role"] = this.role ? this.role.toJSON() : <any>null;
        return data;
    }
}

export interface IUserRole {
    resourceId: string;
    userId: string;
    role: Role;
}

export class TeamUserRole extends UserRole implements ITeamUserRole {
    user?: User | null;

    constructor(data?: ITeamUserRole) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>null;
        }
    }

    static override fromJS(data: any): TeamUserRole {
        data = typeof data === 'object' ? data : {};
        let result = new TeamUserRole();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>null;
        super.toJSON(data);
        return data;
    }
}

export interface ITeamUserRole extends IUserRole {
    user?: User | null;
}

export class TeamUserOfUserAndRole implements ITeamUserOfUserAndRole {
    user?: User | null;
    roles!: Role[];

    constructor(data?: ITeamUserOfUserAndRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.roles = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>null;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(Role.fromJS(item));
            }
            else {
                this.roles = <any>null;
            }
        }
    }

    static fromJS(data: any): TeamUserOfUserAndRole {
        data = typeof data === 'object' ? data : {};
        let result = new TeamUserOfUserAndRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>null;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITeamUserOfUserAndRole {
    user?: User | null;
    roles: Role[];
}

export class TeamAddBotParam implements ITeamAddBotParam {
    name!: string;

    constructor(data?: ITeamAddBotParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): TeamAddBotParam {
        data = typeof data === 'object' ? data : {};
        let result = new TeamAddBotParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export interface ITeamAddBotParam {
    name: string;
}

export class TeamAddEmailParam implements ITeamAddEmailParam {

    constructor(data?: ITeamAddEmailParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): TeamAddEmailParam {
        data = typeof data === 'object' ? data : {};
        let result = new TeamAddEmailParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface ITeamAddEmailParam {
}

export class SignInRequest implements ISignInRequest {
    idToken!: string;
    refreshTokenType!: RefreshTokenType;

    constructor(data?: ISignInRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idToken = _data["idToken"] !== undefined ? _data["idToken"] : <any>null;
            this.refreshTokenType = _data["refreshTokenType"] !== undefined ? _data["refreshTokenType"] : <any>null;
        }
    }

    static fromJS(data: any): SignInRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SignInRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idToken"] = this.idToken !== undefined ? this.idToken : <any>null;
        data["refreshTokenType"] = this.refreshTokenType !== undefined ? this.refreshTokenType : <any>null;
        return data;
    }
}

export interface ISignInRequest {
    idToken: string;
    refreshTokenType: RefreshTokenType;
}

export enum RefreshTokenType {
    None = "None",
    Web = "Web",
    App = "App",
}

export class SignUpRequest implements ISignUpRequest {
    idToken!: string;
    refreshTokenType!: RefreshTokenType;

    constructor(data?: ISignUpRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idToken = _data["idToken"] !== undefined ? _data["idToken"] : <any>null;
            this.refreshTokenType = _data["refreshTokenType"] !== undefined ? _data["refreshTokenType"] : <any>null;
        }
    }

    static fromJS(data: any): SignUpRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SignUpRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idToken"] = this.idToken !== undefined ? this.idToken : <any>null;
        data["refreshTokenType"] = this.refreshTokenType !== undefined ? this.refreshTokenType : <any>null;
        return data;
    }
}

export interface ISignUpRequest {
    idToken: string;
    refreshTokenType: RefreshTokenType;
}

export class RefreshTokenRequest implements IRefreshTokenRequest {
    refreshToken!: string;

    constructor(data?: IRefreshTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"] !== undefined ? _data["refreshToken"] : <any>null;
        }
    }

    static fromJS(data: any): RefreshTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken !== undefined ? this.refreshToken : <any>null;
        return data;
    }
}

export interface IRefreshTokenRequest {
    refreshToken: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}

export class ApiException extends Error {
    statusCode: number;
    response?: string;
    exceptionTypeName?: string;
    exceptionTypeFullName?: string;
    headers: any;
    data: any = {};

    constructor(
        message: string,
        statusCode: number,
        response?: any,
        headers?: any,
        innerException?: Error | null
    ) {
        if (!(response instanceof String)) response = JSON.stringify(response);
        super(ApiException.buildMessage(message, statusCode, response));
        Object.setPrototypeOf(this, ApiException.prototype);

        this.statusCode = statusCode;
        this.response = response;
        this.headers = headers;

        let serverException: ServerException | null = ServerException.tryParse(response);
        if (serverException) {
            Object.keys(serverException.Data).forEach((key) => {
                if (serverException)
                    this.data[key] = serverException.Data[key];
            });
            this.exceptionTypeName = serverException.TypeName;
            this.exceptionTypeFullName = serverException.TypeFullName;
        }

        if (innerException) {
            this.stack = innerException.stack;
        }
    }

    private static buildMessage(
        message: string,
        statusCode: number,
        response?: string
    ): string {
        let serverException = ServerException.tryParse(response);
        if (serverException)
            return serverException.Message || '';

        return `${message}\n\nStatus: ${statusCode}\nResponse:\n${response?.substring(0, Math.min(512, response.length))}`;
    }

    override toString(): string {
        return `HTTP Response:\n\n${this.response}\n\n${super.toString()}`;
    }
}

class ServerException {
    Data!: { [key: string]: string | null };
    TypeName?: string;
    TypeFullName?: string;
    Message?: string;

    public static tryParse(value: string | undefined): ServerException | null {
        if (!value)
            return null;

        try {
            let serverException: ServerException = JSON.parse(value);
            return serverException.TypeName ? serverException : null;
        } catch {
            return null;
        }
    }
}
